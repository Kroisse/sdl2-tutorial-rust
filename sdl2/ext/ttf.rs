use libc::{c_int};

use super::super::{get_error, Color};
use super::super::surface::{Surface};

mod ll {
    /* automatically generated by rust-bindgen */
    #![allow(dead_code, non_camel_case_types, uppercase_variables)]

    use libc::{c_void, c_int, c_long, c_schar};
    pub use ll::{Uint16, Uint32, SDL_version, SDL_Color, SDL_RWops,
                 SDL_Surface, SDL_Renderer, SDL_Texture};
    pub type Struct__TTF_Font = c_void;
    pub type TTF_Font = Struct__TTF_Font;

    #[link(name = "SDL2_ttf", kind = "framework")]
    extern "C" {
        pub fn TTF_Linked_Version() -> *SDL_version;
        pub fn TTF_ByteSwappedUNICODE(swapped: c_int);
        pub fn TTF_Init() -> c_int;
        pub fn TTF_OpenFont(file: *c_schar, ptsize: c_int) -> *mut TTF_Font;
        pub fn TTF_OpenFontIndex(file: *c_schar, ptsize: c_int, index: c_long) ->
         *mut TTF_Font;
        pub fn TTF_OpenFontRW(src: *mut SDL_RWops, freesrc: c_int, ptsize: c_int)
         -> *mut TTF_Font;
        pub fn TTF_OpenFontIndexRW(src: *mut SDL_RWops, freesrc: c_int,
                                   ptsize: c_int, index: c_long) -> *mut TTF_Font;
        pub fn TTF_GetFontStyle(font: *TTF_Font) -> c_int;
        pub fn TTF_SetFontStyle(font: *mut TTF_Font, style: c_int);
        pub fn TTF_GetFontOutline(font: *TTF_Font) -> c_int;
        pub fn TTF_SetFontOutline(font: *mut TTF_Font, outline: c_int);
        pub fn TTF_GetFontHinting(font: *TTF_Font) -> c_int;
        pub fn TTF_SetFontHinting(font: *mut TTF_Font, hinting: c_int);
        pub fn TTF_FontHeight(font: *TTF_Font) -> c_int;
        pub fn TTF_FontAscent(font: *TTF_Font) -> c_int;
        pub fn TTF_FontDescent(font: *TTF_Font) -> c_int;
        pub fn TTF_FontLineSkip(font: *TTF_Font) -> c_int;
        pub fn TTF_GetFontKerning(font: *TTF_Font) -> c_int;
        pub fn TTF_SetFontKerning(font: *mut TTF_Font, allowed: c_int);
        pub fn TTF_FontFaces(font: *TTF_Font) -> c_long;
        pub fn TTF_FontFaceIsFixedWidth(font: *TTF_Font) -> c_int;
        pub fn TTF_FontFaceFamilyName(font: *TTF_Font) -> *mut c_schar;
        pub fn TTF_FontFaceStyleName(font: *TTF_Font) -> *mut c_schar;
        pub fn TTF_GlyphIsProvided(font: *TTF_Font, ch: Uint16) -> c_int;
        pub fn TTF_GlyphMetrics(font: *mut TTF_Font, ch: Uint16, minx: *mut c_int,
                                maxx: *mut c_int, miny: *mut c_int,
                                maxy: *mut c_int, advance: *mut c_int) -> c_int;
        pub fn TTF_SizeText(font: *mut TTF_Font, text: *c_schar, w: *mut c_int,
                            h: *mut c_int) -> c_int;
        pub fn TTF_SizeUTF8(font: *mut TTF_Font, text: *c_schar, w: *mut c_int,
                            h: *mut c_int) -> c_int;
        pub fn TTF_SizeUNICODE(font: *mut TTF_Font, text: *Uint16, w: *mut c_int,
                               h: *mut c_int) -> c_int;
        pub fn TTF_RenderText_Solid(font: *mut TTF_Font, text: *c_schar,
                                    fg: SDL_Color) -> *mut SDL_Surface;
        pub fn TTF_RenderUTF8_Solid(font: *mut TTF_Font, text: *c_schar,
                                    fg: SDL_Color) -> *mut SDL_Surface;
        pub fn TTF_RenderUNICODE_Solid(font: *mut TTF_Font, text: *Uint16,
                                       fg: SDL_Color) -> *mut SDL_Surface;
        pub fn TTF_RenderGlyph_Solid(font: *mut TTF_Font, ch: Uint16,
                                     fg: SDL_Color) -> *mut SDL_Surface;
        pub fn TTF_RenderText_Shaded(font: *mut TTF_Font, text: *c_schar,
                                     fg: SDL_Color, bg: SDL_Color) ->
         *mut SDL_Surface;
        pub fn TTF_RenderUTF8_Shaded(font: *mut TTF_Font, text: *c_schar,
                                     fg: SDL_Color, bg: SDL_Color) ->
         *mut SDL_Surface;
        pub fn TTF_RenderUNICODE_Shaded(font: *mut TTF_Font, text: *Uint16,
                                        fg: SDL_Color, bg: SDL_Color) ->
         *mut SDL_Surface;
        pub fn TTF_RenderGlyph_Shaded(font: *mut TTF_Font, ch: Uint16,
                                      fg: SDL_Color, bg: SDL_Color) ->
         *mut SDL_Surface;
        pub fn TTF_RenderText_Blended(font: *mut TTF_Font, text: *c_schar,
                                      fg: SDL_Color) -> *mut SDL_Surface;
        pub fn TTF_RenderUTF8_Blended(font: *mut TTF_Font, text: *c_schar,
                                      fg: SDL_Color) -> *mut SDL_Surface;
        pub fn TTF_RenderUNICODE_Blended(font: *mut TTF_Font, text: *Uint16,
                                         fg: SDL_Color) -> *mut SDL_Surface;
        pub fn TTF_RenderText_Blended_Wrapped(font: *mut TTF_Font, text: *c_schar,
                                              fg: SDL_Color, wrapLength: Uint32)
         -> *mut SDL_Surface;
        pub fn TTF_RenderUTF8_Blended_Wrapped(font: *mut TTF_Font, text: *c_schar,
                                              fg: SDL_Color, wrapLength: Uint32)
         -> *mut SDL_Surface;
        pub fn TTF_RenderUNICODE_Blended_Wrapped(font: *mut TTF_Font,
                                                 text: *Uint16, fg: SDL_Color,
                                                 wrapLength: Uint32) ->
         *mut SDL_Surface;
        pub fn TTF_RenderGlyph_Blended(font: *mut TTF_Font, ch: Uint16,
                                       fg: SDL_Color) -> *mut SDL_Surface;
        pub fn TTF_CloseFont(font: *mut TTF_Font);
        pub fn TTF_Quit();
        pub fn TTF_WasInit() -> c_int;
        pub fn TTF_GetFontKerningSize(font: *mut TTF_Font, prev_index: c_int,
                                      index: c_int) -> c_int;
    }
}

pub fn init() -> Result<(), StrBuf> {
    unsafe {
        if ll::TTF_Init() < 0 {
            return Err(get_error());
        }
    }
    Ok(())
}

pub fn quit() {
    unsafe { ll::TTF_Quit() }
}

pub struct Font {
    p_font: *mut ll::TTF_Font,
    size: int,
}

impl Font {
        pub fn new(path: &Path, size: int) -> Result<Font, StrBuf> {
        let font = unsafe {
            path.with_c_str(|p| { ll::TTF_OpenFont(p, size as c_int) })
        };
        if font.is_null() {
            Err(get_error())
        } else {
            Ok(Font {p_font: font, size: size})
        }
    }

    pub fn size(&self) -> int { self.size }

        pub fn render_blended(&self, message: &str, foreground: Color) -> Result<Surface, StrBuf> {
        let surface = unsafe {
            message.with_c_str(|m| ll::TTF_RenderText_Blended(self.p_font, m, foreground))
        };
        if surface.is_null() {
            Err(get_error())
        } else {
            Ok(Surface {p_surface: surface})
        }
    }
}

impl Drop for Font {
        fn drop(&mut self) {
        unsafe { ll::TTF_CloseFont(self.p_font) }
    }
}
